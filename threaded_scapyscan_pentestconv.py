import threading
import Queue
from scapy.all import *
import sys
from datetime import *
from os import system

os.system('clear') ## clear the terminal on running script

print_lock = threading.Lock() # defines Lock as print lock to prevent threads accessing print function at same time

# get range of IP to scan from user command line input using sys module

s_IP = str(sys.argv[1])
e_IP = str(sys.argv[2])

iplist1 = sys.argv[1].split('.') ## pulls each octet as a seperate item in list iplist
iplist2 = sys.argv[2].split('.') ## same as above

last_IP_octet1 = int(iplist1[3]) ## pulls last octet of IP address from list iplist
last_IP_octet2 = int(iplist2[3]) ## same as above

n_addr = str(iplist1[0] + '.' + iplist1[1] + '.' + iplist1[2])  # build the first

s_port = int(sys.argv[3])
e_port = int(sys.argv[4])

macaddr = []
livehosts = []

open_port = []
closed_port = []
filtered_port = []

def arp_scan(ipaddr):   # using scapy to build and ARP request to each IP in range. Live hosts should respond
                        # with an ARP reply. srp1 rather than sr because we are sending across layer 2 rather
                        # than layer 3

    arp_packet = Ether(dst='ff:ff:ff:ff:ff:ff') / ARP(pdst=ipaddr)  # wraps arp packet in ethernet frame with the
                                                                    # broadcast address set.

    arp_resp = srp1(arp_packet, timeout=2, verbose=0, retry=1)  # sending arp packet (srp1 as this is over layer 2)
                                                                # and then writes first response to memory

    if not (arp_resp is None):
        with print_lock:
            print 'Host: %s is live' % ipaddr
            macaddr.append(arp_resp.getlayer(ARP).psrc)
            macaddr.append(arp_resp.getlayer(ARP).hwsrc)
            livehosts.append(arp_resp.getlayer(ARP).psrc)
        return livehosts
        return macaddr
    else:
        pass
# check if arp response received and append IP to live hosts and MAC addr to list



def thread_arp():
    q = Queue.Queue()

    def threader_arp():
        while True:
            worker = q.get()
            arp_scan(worker)
            q.task_done()
    # pull a worker thread from q and assign it an IP addr to deed into FUnc arp_scan

    for x in range(30):
        t = threading.Thread(target=threader_arp)
        t.daemon = True
        t.start()
    # create a worker thread up too 30 (higher the faster the scan but the more intensive. 30 chosen arbitrarily.

    for y in range(last_IP_octet1, last_IP_octet2):
        worker = n_addr + '.' + str(y)
        q.put(worker)

    q.join()



def tcp_syn_scan(ipaddr, port):

    # this function replicates the nmap syn scan functionality. The TCP packet is created with flag S (SYN) set.
    # This is wrapped in the IP segment and IP dst is set. A response is then checked for and checked against the
    # following rules.
    # 1. if rsp = rst then port is closed
    # 2. if rsp = SYN-ACK (0x12) then port is open
    # 3. if an ICMP error message with codes 1, 2, 3, 9, 10, 13 is recieved then the port is being filtered.
    # 4. if noting is recieved then the port is being filtered as packets are gettin droppped on route to target



    packet = IP(dst=ipaddr) / TCP(dport=port, flags='S')
    response = sr1(packet, timeout=2, verbose=0, retry=1)

    if not (response is None):
        if response.haslayer(TCP) and response.getlayer(TCP).flags == 0x12:
            with print_lock:
                try:
                    service = socket.getservbyport(port, 'tcp')
                except:
                    pass
                if service is not None:
                    print '%-10s %-10s %-10s' % (str(port) + '/tcp', 'open', service)
                else:
                    print '%-10s %-10s %-10s' % (str(port) + '/tcp', 'open', 'port/proto not found')
                open_port.append(port)


        elif response.haslayer(TCP) and response.getlayer(TCP).flags == 0x14:  # check the reply for a rst flag
            closed_port.append(port)

        elif response.haslayer(ICMP) and response.getlayer(ICMP).type == 3:

            if int(response.getlayer(ICMP).code) in [1, 2, 3, 9, 10, 13]:
                filtered_port.append(port)
                return filtered_port

    else:
        filtered_port.append(port)
        return filtered_port
        pass





def thread_tcp():   # for each IP we scan the range of ports.
                    # To speed this up I've implemented threading which allows mutiple ports to be scanned at the
                    # same time

    q = Queue.Queue()
    target = 0

    while target < int(len(livehosts)): # iterated through the live host list generated by the arp sweep

        print '\nScanning IP: %s' %str(livehosts[target])

        if str(livehosts[target]) in macaddr:
            mac_index = int(macaddr.index(livehosts[target]))+1
            mac = macaddr[mac_index]
            print 'MAC Address: %s' % mac
        else:
            pass

        ipaddr = str(livehosts[target])
        print '%-10s %-10s %-10s' % ('PORT', 'STATUS', 'SERVICE')

        def threader_tcp():
            while True:
                worker = q.get()
                tcp_syn_scan(ipaddr, worker)
                q.task_done()

        for x in range(100):
            t = threading.Thread(target=threader_tcp)
            t.daemon = True
            t.start()

        for y in range(s_port, e_port):
            worker = int(y)
            q.put(worker)

        target+=1
        q.join()
        print '%s ports are filtered \n%s ports are closed' %(len(filtered_port), len(closed_port))

        del (closed_port[:], open_port[:], filtered_port[:])




def main():

    timer1 = datetime.now()

    print 'ARP scan: IP range %s to %s\n' % (s_IP, e_IP)
    thread_arp()
    print '\n%s live hosts discovered' % len(livehosts)

    if len(livehosts) == 0:
        print 'Scan aborted'
        sys.exit()

    print 'Starting stealth scan of live hosts\n'
    print 'Scanning port range: %s to %s' % (s_port, e_port)
    thread_tcp()


    timer2 = datetime.now()

    print '\nScan started at ' + timer1.strftime("%H:%M:%S") + ' on ' + timer1.strftime("%b %d %Y")
    print 'Scan finished at ' + timer2.strftime("%H:%M:%S") + ' on ' + timer2.strftime("%b %d %Y")

    timer1 = timedelta(days=timer1.day, hours=timer1.hour, minutes=timer1.minute, seconds=timer1.second)
    timer2 = timedelta(days=timer2.day, hours=timer2.hour, minutes=timer2.minute, seconds=timer2.second)

    t_duration = timer2 - timer1

    print 'Scan completed in ' + str(t_duration)


main()
sys.exit()
